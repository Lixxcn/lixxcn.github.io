# 第11章 为分类任务微调表示模型
## Q130：在微调任务中，应该冻结哪些层的权重？微调编码器前几层、编码器后几层、前馈神经网络层有什么区别？

**答案：**

在微调任务中，冻结哪些层的权重是一个重要的超参数，取决于多种因素，如任务与预训练任务的相似度、数据集大小、计算资源等。通常有以下几种策略：

1.  **只微调分类头 (Classifier Head)**：
    *   **做法**：冻结所有编码器层的权重，只训练新添加的分类层。
    *   **适用场景**：
        *   下游任务的数据集非常小，微调整个模型容易过拟合。
        *   下游任务与预训练任务非常相似，预训练模型学习到的特征已经足够好。
        *   计算资源非常有限，这是最快、最节省资源的微调方式。
    *   **优点**：训练速度快，需要算力少，不易过拟合。
    *   **缺点**：模型性能提升有限，因为没有调整底层特征表示。

2.  **微调部分编码器层**：
    *   **微调编码器后几层 (Higher Layers)**：
        *   **做法**：冻结编码器前几层（例如，BERT 的前 8-10 层），微调后几层和分类头。
        *   **区别**：BERT 等模型的底层（前几层）学习到的是更通用的语言特征（如词法、句法结构），而高层（后几层）学习到的是更抽象、更接近具体任务的语义特征。微调后几层可以在保留通用语言能力的基础上，让模型更好地适应新任务的特定语义。
        *   **适用场景**：这是最常见的微调策略。当数据集大小适中，且任务需要模型学习新的高层语义特征时，这种方法在性能和效率之间取得了很好的平衡。

    *   **微调编码器前几层 (Lower Layers)**：
        *   **做法**：冻结后几层，微调前几层。这种情况比较少见。
        *   **区别**：微调前几层意味着要改变模型对基础语言特征的理解，这通常只在下游任务的文本分布与预训练语料库有显著差异时才考虑（例如，从通用文本微调到代码、化学分子式等特殊领域）。
        *   **适用场景**：非常罕见，通常不推荐，因为可能会破坏模型已经学好的通用语言基础。

3.  **微调所有层 (Full Fine-tuning)**：
    *   **做法**：不冻结任何编码器层，训练所有权重（通常使用比预训练更小的学习率）。
    *   **适用场景**：
        *   拥有大规模的标注数据集，足以支持训练整个模型而不过拟合。
        *   下游任务与预训练任务差异较大，需要对模型的各层特征进行全面调整。
        *   对模型性能要求极高，且计算资源充足。
    *   **优点**：通常能达到最佳性能。
    *   **缺点**：计算成本高，训练时间长，在小数据集上容易过拟合。

**微调前馈神经网络层 (Feed-Forward Neural Network, FFN)**

在 Transformer 的每一层中，都包含一个多头自注意力（Multi-Head Self-Attention）子层和一个前馈神经网络（FFN）子层。只微调 FFN 层也是一种策略，例如 Adapter-based tuning（如 LoRA 的变体）就是基于这个思想。

*   **区别**：
    *   **FFN 层**：被认为是存储和应用模型在预训练中学到的“知识”或“事实”的地方。
    *   **自注意力层**：主要负责理解词元之间的关系和上下文依赖。
    *   微调 FFN 层可以看作是在不改变模型核心上下文理解能力的情况下，向模型注入新的知识或调整其知识应用的方式。这种方法比完全微调更高效，参数更新量更少。

**总结**

| 策略 | 冻结层 | 微调层 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **分类头微调** | 所有编码器层 | 分类头 | 速度快，资源消耗少，不易过拟合 | 性能提升有限 | 数据集极小，任务与预训练相似 |
| **后几层微调** | 编码器前几层 | 编码器后几层 + 分类头 | 性能和效率的良好平衡 | 可能不是最优性能 | 最常用，数据集大小适中 |
| **全模型微调** | 无 | 所有层 | 性能潜力最大 | 计算成本高，易过拟合 | 数据集大，任务差异大，追求极致性能 |
| **前几层微调** | 编码器后几层 | 编码器前几层 + 分类头 | (理论上)适应新领域文本分布 | 破坏通用特征，效果不稳定 | 极少使用，不推荐 |
| **仅微调 FFN** | 注意力层 | FFN 层 | 参数高效，节省资源 | 性能可能不如全模型微调 | 参数高效微调（PEFT）场景 |
## Q131：如果有标注的训练数据很少，如何扩增训练数据的数量？（提示：SetFit）

**答案：**

当有标注的训练数据很少（Few-shot learning）时，扩增训练数据是提升模型性能的关键。除了传统的数据增强方法，SetFit 框架提供了一种非常高效的思路。以下是几种主要的数据扩增方法：

**1. 传统数据增强 (Traditional Data Augmentation)**

这些方法在文本的词汇或句子层面进行微小改动，生成新的样本，同时保持标签不变。

*   **同义词替换 (Synonym Replacement)**：随机选择句子中的一些非停用词，用它们的同义词替换。例如，“这个苹果很美味” -> “这个苹果很可口”。
*   **随机插入 (Random Insertion)**：在句子中随机插入一个同义词。
*   **随机交换 (Random Swap)**：随机交换句子中两个词的位置。
*   **随机删除 (Random Deletion)**：以一定的概率随机删除句子中的词。
*   **回译 (Back-translation)**：将句子翻译成另一种语言，再翻译回原始语言。例如，中文 -> 英文 -> 中文。这个过程通常会产生语义相似但表达方式不同的新句子。

**2. 使用大语言模型生成伪标签 (Pseudo-labeling with LLMs)**

可以利用强大的预训练语言模型（如 GPT-3/4）来生成新的训练样本。

*   **零样本/少样本提示 (Zero-shot/Few-shot Prompting)**：给 LLM 一个任务描述和几个例子（Few-shot）或不给例子（Zero-shot），让它为大量无标签数据生成标签。这些带有“伪标签”的数据可以作为额外的训练样本。
*   **指令微调模型生成 (Instruction-tuned LLM Generation)**：使用像 `flan-t5` 或 `GPT-4` 这样的模型，通过精心设计的指令来生成新的、符合特定类别要求的训练样本。

**3. SetFit 框架的思路：基于无监督数据生成丰富的句子对**

SetFit (Sentence Transformer Fine-tuning) 的核心思想与传统的数据增强不同，它不直接扩增带标签的样本数量，而是在无标签数据上通过**对比学习 (Contrastive Learning)** 来微调一个句子嵌入模型 (Sentence Transformer)，使其能为下游任务生成高质量的特征表示。这个过程本身就是一种高效的“数据利用”方式。

*   **核心步骤**：
    1.  **生成句子对**：从**无标签**的语料库中（可以是你的领域数据）生成大量的正负句子对。最简单的方式是“in-batch negatives”：同一个 batch 内，一个句子自身是正例，其他所有句子都是负例。
    2.  **对比学习微调**：使用这些句子对，通过对比损失函数（如 MultipleNegativesRankingLoss）来微调 Sentence Transformer。目标是让相似的句子在向量空间中更接近，不相似的句子更疏远。这一步完全是**无监督**的。
    3.  **训练分类头**：使用微调后的 Sentence Transformer 为**少量带标签**的训练数据生成高质量的嵌入向量 (Embeddings)。然后，只用这些嵌入向量来训练一个简单的分类头（如 Logistic Regression）。

*   **如何“扩增”数据**：
    SetFit 的巧妙之处在于，它将数据增强的压力从“生成更多带标签样本”转移到了“从海量无标签数据中学习更好的句子表示”。它通过在无监督数据上进行对比学习，极大地提升了模型对领域内文本的理解能力。这样，即使只有极少数（例如，每个类别只有 8 个）的标注样本，模型也能因为学到了优质的特征而表现出色。可以说，SetFit 利用了无标签数据来“增强”了特征提取器的能力，从而间接达到了数据扩增的效果。

**总结**

| 方法 | 核心思想 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **传统数据增强** | 对原始句子做微小改动 | 实现简单，快速 | 可能引入噪声，语义漂移风险 |
| **LLM 生成伪标签** | 利用大模型为无标签数据打标 | 可生成高质量、多样化的数据 | 依赖强大 LLM，成本高，伪标签可能不准 |
| **SetFit** | 在无标签数据上对比学习，优化句子表示 | 在极少样本下性能优异，高效利用无标签数据 | 需要一个好的 Sentence Transformer 作为起点，流程稍复杂 |
## Q132：SetFit 在训练分类头之前，会先利用对比学习微调 Sentence Transformer。为什么这个微调步骤对于在极少标注样本下取得高性能至关重要？

**答案：**

这个对比学习微调步骤之所以至关重要，是因为它**将模型的学习重点从“有监督分类”转向了“无监督的语义表示学习”**，从而解决了极少标注样本场景下的核心痛点：**数据稀疏和过拟合风险**。

具体来说，其重要性体现在以下几个方面：

**1. 充分利用无标签数据，克服标注瓶颈**

*   **问题**：在少样本场景下，最大的问题就是带标签的数据太少（例如，每个类别只有 8-16 个样本）。如果直接用这些样本来微调一个大型的 Transformer 模型，模型几乎无法学习到有效的类别区分特征，并且极易过拟合，记住的只是这几个样本本身，而不是通用的规律。
*   **SetFit 的解决方案**：对比学习是**无监督**的。它不需要标签，只需要大量的原始文本。SetFit 利用这些丰富的无标签数据（可以是领域相关的任何文本）来生成成千上万的句子对。通过微调，模型被强制去理解哪些句子在语义上是相似的，哪些是不同的。这使得模型能够学习到领域内文本的细微差别和语义结构，而这些知识是仅靠几个标注样本无法获得的。

**2. 生成高质量、任务相关的句子嵌入**

*   **问题**：一个通用的、未经微调的 Sentence Transformer（例如，直接用 `all-MiniLM-L6-v2`）提供的嵌入向量是“通用”的，它可能无法很好地捕捉特定下游任务所需的语义差异。例如，在情感分类任务中，“这家餐厅的服务很棒”和“这家餐厅的食物很棒”都应被视为正面情感，它们的嵌入向量应该比较接近。一个通用模型可能无法很好地体现这种“任务特定”的相似性。
*   **SetFit 的解决方案**：通过对比学习微调，Sentence Transformer 被“校准”或“对齐”到了目标任务的语义空间。即使没有标签，模型通过学习区分句子对，其产生的嵌入向量也变得更加“任务感知”。微调后的模型能够生成更具区分度的嵌入，使得属于同一类别的句子在向量空间中聚集得更近，不同类别的句子则被推得更远。这为后续训练分类头打下了坚实的基础。

**3. 降低分类头的学习难度，避免过拟合**

*   **问题**：如果直接将通用嵌入向量喂给分类头，分类头需要承担很重的学习任务：它既要理解这些通用嵌入，又要从中找到分类的决策边界。在样本很少的情况下，这几乎是不可能完成的任务。
*   **SetFit 的解决方案**：由于对比学习已经产生了高质量、高区分度的嵌入向量，分类头的任务变得异常简单。它不再需要学习复杂的特征，只需在已经清晰分离开的向量簇之间画一条线（决策边界）即可。因此，一个非常简单的分类器（如逻辑回归）就足够了。训练一个简单的分类器在少量数据上几乎没有过拟合的风险。

**总结：**

SetFit 的对比学习步骤是其成功的关键，它巧妙地将学习的重心从依赖稀缺的“标签”转移到了利用丰富的“无标签文本”。这个步骤相当于一个**无监督的预热过程**，它为模型注入了宝贵的领域知识和任务相关的语义理解能力，从而为后续的分类任务铺平了道路。没有这一步，直接在极少样本上进行训练，效果将大打折扣，远不如这种先进行无监督表示学习、再进行有监督分类的范式。这正是 SetFit “少样本、高效率”的秘诀所在。
## Q133：相比直接使用一个冻结的通用 Sentence Transformer 提取嵌入向量再训练分类器，SetFit 的对比学习微调方法能让嵌入向量学习到哪些更适用于下游分类任务的特性？

**答案：**

相比直接使用一个冻结的通用 Sentence Transformer，SetFit 的对比学习微调方法能让嵌入向量学习到以下几个关键的、更适用于下游分类任务的特性：

**1. 任务导向的语义相似性 (Task-Oriented Semantic Similarity)**

*   **通用模型**：学习的是**通用**的语义相似性。例如，“苹果公司发布了新手机”和“谷歌发布了新系统”在通用语义上是相似的（都是关于科技公司发布新产品）。
*   **SetFit 微调后**：学习的是**任务特定**的语义相似性。假设下游任务是情感分类，模型会学到“我喜欢这家餐厅”和“这家店的食物太棒了”是相似的（都表达正面情感），即使它们的字面内容差异很大。而“这家餐厅价格很高”和“这家餐厅价格很低”在情感任务上则是不相似的。这种对相似性的重新定义是适应下游任务的关键。

**2. 更强的类别区分度 (Enhanced Class Separability)**

*   **通用模型**：其生成的嵌入向量在向量空间中的分布是基于通用语言规律的，不一定会让不同类别的样本在空间上自然分开。
*   **SetFit 微调后**：通过对比学习（将正例拉近，负例推远），模型被显式地训练去**最大化不同语义簇之间的距离**。这使得微调后的嵌入向量天然地具有了**高内聚、低耦合**的特性：同一类别的句子嵌入会聚集在一起形成紧密的簇，而不同类别的簇之间则会有清晰的边界。这大大降低了后续分类器的学习难度。

**3. 领域适应性 (Domain Adaptation)**

*   **通用模型**：在通用语料（如维基百科、新闻）上预训练，可能不理解特定领域的术语或语境。例如，在医疗领域，“stable”可能指“病情稳定”，而不是“稳定的结构”。
*   **SetFit 微调后**：由于对比学习可以在**目标领域的无标签数据**上进行，模型能够学习到该领域的特定语言模式、术语和上下文。这使得嵌入向量能够更好地捕捉领域内的细微语义差别，从而提升在专业领域的分类性能。

**4. 对噪声和无关信息的鲁棒性 (Robustness to Noise and Irrelevant Information)**

*   **通用模型**：可能会被句子中的一些与分类任务无关的词语干扰。
*   **SetFit 微调后**：模型学会了专注于对分类任务有决定性作用的语义特征，而忽略那些无关紧要的细节。例如，在判断一个影评是正面还是负面时，模型会更关注“精彩”、“失望”这类情感词，而不是“电影院”、“演员名字”等中性信息。嵌入向量会更多地编码前者而不是后者。

**一个直观的例子：**

假设任务是**将新闻标题分为“体育”和“科技”两类**。

*   **句子 A**：“XX 队在决赛中击败对手，夺得冠军”
*   **句子 B**：“XX 队宣布与某科技公司达成赞助协议”
*   **句子 C**：“某科技公司发布新款芯片，性能大幅提升”

对于一个**冻结的通用模型**：
*   句子 A 和 B 可能因为都包含“XX 队”而具有较高的语义相似度。
*   句子 B 和 C 可能因为都包含“科技公司”而具有较高的语义相似度。
*   这种模糊的相似性对于分类任务是不利的。

经过 **SetFit 的对比学习微调**后（假设在新闻语料上进行）：
*   模型会学到，对于体育/科技分类任务，“夺得冠军”是体育类的核心特征，而“发布芯片”是科技类的核心特征。
*   因此，句子 A 的嵌入会更接近其他体育新闻，而句子 C 的嵌入会更接近其他科技新闻。
*   句子 B 的嵌入可能会根据上下文被推向体育类或科技类，或者处于两者之间，但 A 和 C 这两个典型样本的嵌入一定会被清晰地分离开来。

总之，SetFit 的对比学习微调过程，本质上是对通用嵌入空间的一次“重塑”和“优化”，使其从一个“通用”的语义空间转变为一个为特定分类任务“量身定制”的高效特征空间。
## Q134：在继续预训练时，如何在保证模型获得特定领域知识的同时，最大程度保留其通用能力？

**答案：**

在继续预训练（Continual Pre-training）中，平衡领域知识的注入和通用能力的保留是一个核心挑战，这个现象通常被称为“灾难性遗忘”（Catastrophic Forgetting）。为了解决这个问题，可以采用以下几种策略：

**1. 混合语料库训练 (Mixed Corpus Training)**

这是最直接有效的方法。在继续预训练时，不要只使用领域数据，而是将**领域数据**和**原始的通用数据**（或其一部分）混合在一起进行训练。

*   **做法**：创建一个新的训练语料库，其中包含例如 50% 的领域文本（如医疗、法律文档）和 50% 的通用文本（如维基百科、新闻）。
*   **优点**：通过在每个训练批次中都接触到通用数据，模型可以不断“复习”已经学到的通用语言知识，从而有效减缓遗忘。
*   **缺点**：需要存储和处理原始通用数据，增加了数据准备的复杂性和存储成本。

**2. 较低的学习率 (Lower Learning Rate)**

相比于从头预训练，继续预训练时应该使用更低的学习率。

*   **做法**：通常选择比原始预训练小一个数量级的学习率（例如，从 `1e-4` 降到 `1e-5`）。
*   **原理**：较低的学习率意味着每次参数更新的步长更小。这使得模型在学习新知识时更加“小心翼翼”，不会因为领域数据的梯度而剧烈地改变已经学好的通用权重，从而在适应新领域的同时，更好地保留了原有的能力。

**3. 弹性权重巩固 (Elastic Weight Consolidation, EWC)**

EWC 是一种更高级的算法，它通过限制重要权重的改变来防止遗忘。

*   **做法**：
    1.  首先，评估模型在原始通用任务上的每个权重的重要性（通常用费雪信息矩阵来近似）。对于通用能力越重要的权重，其重要性得分越高。
    2.  在继续预训练的损失函数中，增加一个正则化项。这个正则化项会惩罚那些对通用能力很重要的权重的剧烈变化。
*   **优点**：提供了一种更精细化的方式来保护重要知识，理论上比简单降低学习率更有效。
*   **缺点**：实现相对复杂，需要计算和存储每个权重的重要性得分。

**4. 参数高效微调技术 (Parameter-Efficient Fine-Tuning, PEFT)**

虽然 PEFT 通常用于下游任务微调，但其思想也可以借鉴到继续预训练中。核心思想是冻结大部分原始模型参数，只训练少量新添加的参数。

*   **做法**：例如，使用**Adapter**或**LoRA**。冻结预训练模型的绝大部分权重，只在模型的某些层中插入少量可训练的“适配器”模块或低秩矩阵。只在领域数据上训练这些新增的参数。
*   **优点**：由于原始模型的骨干网络被冻结，其通用能力被完美地保留了下来。领域知识被“注入”到了新增的模块中。这种方法非常高效，大大减少了需要训练的参数量和计算资源。
*   **缺点**：可能会轻微牺牲一些性能，因为模型的全部参数没有被充分利用来适应新领域。

**5. 逐步降低学习率和解冻层 (Gradual Unfreezing and Staged Learning Rate)**

这是一种分阶段的训练策略。

*   **做法**：
    1.  **阶段一**：冻结所有层，只在领域数据上训练新添加的语言模型头（如果有的话）或最高几层，使用较高的学习率。
    2.  **阶段二**：解冻后面几层，使用稍低的学习率进行训练。
    3.  **阶段三**：解冻所有层，使用非常低的学习率进行全局训练。
*   **优点**：通过由上至下、由粗到细的调整，模型可以平稳地适应新领域，同时减少对底层通用特征的破坏。

**总结**

| 策略 | 核心思想 | 实现难度 | 效果 |
| :--- | :--- | :--- | :--- |
| **混合语料库** | 同时接触新旧知识 | 简单 | 非常有效，是基准方法 |
| **低学习率** | 小步长更新，减少剧变 | 极简单 | 基础且必要的操作 |
| **EWC** | 惩罚重要权重的改变 | 复杂 | 理论上更优，但实现成本高 |
| **PEFT (Adapter/LoRA)** | 冻结主干，只训练附加参数 | 中等 | 完美保留通用能力，资源高效 |
| **分阶段解冻** | 从上到下，逐步适应 | 中等 | 平滑过渡，防止底层特征被破坏 |

在实践中，最常用且有效的方法是**混合语料库训练**和**使用较低的学习率**。如果对计算资源有严格限制，**PEFT** 是一个极具吸引力的选择。
## Q135：请比较以下三种方案在垂直领域文本分类任务上的优缺点：(a) 直接使用通用 BERT 模型微调；(b) 在医疗文本上继续预训练 BERT 后再微调；(c) 从头开始用医疗文本预训练模型再微调。

**答案：**

这三种方案代表了在垂直领域（如医疗、金融、法律）应用 Transformer 模型时，在成本、性能和数据需求之间的不同权衡。下面对它们的优缺点进行详细比较。

--- 

### (a) 直接使用通用 BERT 模型微调 (Direct Fine-tuning)

*   **做法**：获取一个在通用语料（如维基百科）上预训练好的标准 BERT 模型（如 `bert-base-uncased`），直接在下游的医疗文本分类任务上进行微调。

*   **优点**：
    *   **成本最低、最快**：这是最简单、最快速的方法，不需要额外的预训练阶段，计算成本和时间开销最小。
    *   **实现简单**：技术流程成熟，有大量现成的教程和工具支持。
    *   **对标注数据量要求相对较低**：相比于从头预训练，微调所需的标注数据要少得多。

*   **缺点**：
    *   **性能瓶颈**：模型的“词汇表”和“世界知识”都来自于通用领域。对于医疗领域中大量的专业术语（如疾病名、药品名、手术名）和独特的语法结构，模型可能无法很好地理解，表现为“水土不服”。这会导致性能通常是三者中最差的。
    *   **领域知识缺乏**：模型不知道“阿司匹林”是一种药，也不知道“高血压”和“中风”之间的关系。这种知识的缺乏限制了其深层次的语义理解能力。

--- 

### (b) 在医疗文本上继续预训练 BERT 后再微调 (Continual Pre-training then Fine-tuning)

*   **做法**：
    1.  **领域适应**：获取一个通用的 BERT 模型。
    2.  **继续预训练**：在大量的**无标签**医疗文本上，使用 MLM（掩码语言模型）等任务继续预训练模型，使其适应医疗领域的语言风格和专业词汇。
    3.  **微调**：将在医疗文本上继续预训练过的模型，用于下游的医疗文本分类任务进行微调。

*   **优点**：
    *   **性能和成本的良好平衡**：这是目前业界最主流、性价比最高的方法。它既利用了通用 BERT 强大的基础语言能力，又通过继续预训练向模型注入了宝贵的领域知识。
    *   **高效利用无标签数据**：可以利用海量的、易于获取的无标签领域数据（如医学文献、电子病历）来提升模型能力，而不需要昂贵的标注。
    *   **显著的性能提升**：相比方案 (a)，性能通常有显著提升，因为模型已经学会了领域术语和上下文。

*   **缺点**：
    *   **额外的计算成本**：需要一个继续预训练的阶段，这比直接微调需要更多的计算资源和时间。
    *   **可能遗忘通用知识**：如果在继续预训练时只使用领域数据，可能会导致“灾难性遗忘”，需要采用混合语料库等策略来缓解（见 Q134）。

--- 

### (c) 从头开始用医疗文本预训练模型再微调 (Pre-training from Scratch)

*   **做法**：
    1.  **从零开始**：不使用任何现有的模型权重，随机初始化一个 BERT 模型。
    2.  **完全预训练**：在海量的医疗文本上，从头开始进行完整的预训练过程。
    3.  **微调**：将这个完全在医疗领域预训练好的模型（例如，一个 “ClinicalBERT”）用于下游任务微调。

*   **优点**：
    *   **潜在的最高性能**：模型从一开始就完全沉浸在领域数据中，其词汇表、语法理解和语义知识都与领域高度相关，没有任何通用领域的“包袱”。理论上，这可以达到最佳的领域内性能。
    *   **领域原生**：可以设计一个完全为医疗领域定制的词元分析器（Tokenizer），能更好地处理专业术语，避免通用 Tokenizer 将术语切得支离破碎的问题。

*   **缺点**：
    *   **成本极其高昂**：从头预训练一个 BERT 级别的模型需要海量的计算资源（通常是数千个 GPU/TPU 小时）和时间，成本非常高。
    *   **需要海量的领域数据**：为了从头训练一个强大的模型，需要比继续预训练多得多的领域文本数据。如果数据量不足，模型性能可能还不如方案 (b)。
    *   **缺乏通用常识**：模型可能只懂医疗，但缺乏一些有用的通用世界知识，这在某些需要结合常识的医疗文本理解任务中可能成为短板。

--- 

**总结与选择建议**

| 方案 | 性能潜力 | 成本 | 数据需求 (无标签) | 数据需求 (有标签) | 推荐指数 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| (a) 直接微调 | ★☆☆ | ★★★ (最低) | 无 | 中等 | ★★★☆☆ (快速验证) |
| (b) 继续预训练 | ★★☆ | ★★☆ (中等) | 大量 | 中等 | ★★★★★ (业界首选) |
| (c) 从头预训练 | ★★★ | ★☆☆ (最高) | 海量 | 中等 | ★★☆☆☆ (资源充足时) |

*   **快速原型验证或资源极其有限**：选择 **(a)**。
*   **大多数工业界和学术界应用的标准选择**：选择 **(b)**，这是性能和成本的最佳折中。
*   **拥有海量领域数据和充足计算预算，并追求极致性能的大型机构**：可以考虑 **(c)**。
## Q136：在基于掩码语言建模的继续预训练中，应该如何设计掩码出现的位置和概率？

**答案：**

在基于掩码语言建模（Masked Language Modeling, MLM）的继续预训练中，设计掩码的**位置**和**概率**对于让模型高效学习领域知识至关重要。这需要根据领域特性和训练目标进行权衡，主要有以下几种策略：

### 掩码概率 (Masking Probability)

标准的 BERT 预训练使用了 **15%** 的总词元掩码概率。这是一个很好的基准，但在继续预训练中可以进行调整。

*   **标准 15% 概率**：
    *   **构成**：在被选中的 15% 词元中，80% 被替换为 `[MASK]`，10% 被替换为随机词元，10% 保持不变。
    *   **优点**：这是一个经过充分验证的、稳健的设置，在通用领域表现良好。
    *   **建议**：作为默认选项，通常不需要修改。

*   **更高的掩码概率 (例如 20%-25%)**：
    *   **适用场景**：当你的领域数据非常庞大，或者计算资源充足，希望模型进行更“困难”的学习时。
    *   **优点**：增加了学习任务的难度，可能迫使模型学习更深层次的上下文关系，从而获得更好的表示。
    *   **缺点**：可能导致训练收敛变慢，并且如果数据不够丰富，过高的掩码率会因为上下文信息不足而损害学习效果。

*   **更低的掩码概率 (例如 10%)**：
    *   **适用场景**：领域数据较少，或者文本非常专业、结构化（如代码、API 调用），不希望破坏过多的上下文结构。
    *   **优点**：训练任务更简单，收敛更快，保留了更多的原始句子结构。
    *   **缺点**：学习效率可能较低，因为模型在每个样本上学习到的信息变少了。

### 掩码位置 (Masking Position)

标准 BERT 的掩码位置是**完全随机**的。但在继续预训练中，我们可以设计更智能的掩码策略，以突出领域知识。

**1. 随机掩码 (Random Masking)**

*   **做法**：与 BERT 原始设置一样，在整个句子中随机选择 15% 的词元进行掩码。
*   **优点**：简单、通用，不需要任何先验知识。
*   **缺点**：对于学习特定领域的关键概念，效率可能不是最高的。它平等地对待了所有词元。

**2. 实体/术语掩码 (Entity/Span Masking)**

这是针对垂直领域最有效、最推荐的策略之一。

*   **做法**：
    1.  首先，使用领域词典、正则表达式或简单的实体识别工具，识别出文本中的关键实体或术语（例如，医疗领域的“高血压”、“阿司匹林”，金融领域的“市盈率”、“量化宽松”）。
    2.  在选择要掩码的词元时，**优先掩码这些识别出的实体**。通常是掩码整个实体/短语，而不是其中的单个词元（这也被称为 Whole Word Masking 或 Span Masking 的一种形式）。
*   **优点**：
    *   **高效学习领域知识**：强制模型去学习和预测领域内的核心概念，从而快速掌握领域知识。
    *   **学习实体关系**：通过预测被掩码的实体，模型可以更好地理解实体与其上下文之间的关系。
*   **缺点**：需要构建领域词典或额外的识别工具，增加了预处理的复杂度。

**3. 全词掩码 (Whole Word Masking, WWM)**

*   **做法**：当一个词被 WordPiece 等分词器拆分成多个子词（subwords）时，如果决定要掩码这个词，就**将构成这个词的所有子词一起掩码**。
    *   例如，`unaffordably` -> `un`, `##afford`, `##ably`。如果要掩码 `unaffordably`，则将这三个子词全部替换为 `[MASK]` `[MASK]` `[MASK]`。
*   **优点**：相比于只掩码部分子词，WWM 的任务更难，迫使模型去理解整个词的语义，而不是依赖零碎的子词线索。这对于大多数语言（尤其是中文）都是一个非常有效的改进。
*   **建议**：在继续预训练时，**强烈推荐开启 WWM**。很多预训练模型（如 Google 的中文 BERT）已经默认使用了此策略。

**设计建议总结**

1.  **概率**：从 **15%** 开始。除非有特殊需求和充分的实验，否则不建议大幅修改。
2.  **位置策略**：
    *   **基线**：使用**全词掩码 (WWM)**。这是一个低成本、高回报的改进。
    *   **进阶**：如果想让模型深度学习领域知识，实现**实体/术语掩码**。可以将其与 WWM 结合，即优先选择实体进行掩码，并对选中的实体应用 WWM。
3.  **组合策略**：一个好的实践是混合不同的掩码策略。例如，可以设计一个流程，80% 的情况下使用实体掩码，20% 的情况下使用完全随机的 WWM，以增加训练的多样性。

最终，最佳的掩码策略需要通过在下游任务上的实际表现来评估和选择。
## Q137：在微调过程中，为什么模型对学习率等超参数通常比预训练阶段更敏感？

**答案：**

在微调（Fine-tuning）过程中，模型对学习率等超参数比预训练（Pre-training）阶段更敏感，这主要是由两个阶段的**目标、数据规模和模型状态**的根本差异决定的。

**1. 目标不同：从“知识积累”到“知识适应”**

*   **预训练阶段**：目标是从海量的无标签数据中学习**通用**的语言规律和世界知识。这是一个漫长而稳健的“知识积累”过程。模型需要从一个随机状态开始，通过大量的迭代慢慢收敛。较高的学习率（如 `1e-4`）有助于模型在广阔的参数空间中快速探索和学习。
*   **微调阶段**：目标是将已经学到的通用知识**适应**到一个**特定**的、通常规模小得多的下游任务上。这是一个“精雕细琢”的过程。模型已经处于一个非常好的初始化状态（即预训练好的权重），我们不希望破坏这些宝贵的知识。因此，需要用更小的学习率（如 `2e-5`）来“小心翼翼”地调整权重，使其在不偏离通用知识太远的前提下，拟合下游任务的数据。

**2. 数据规模差异巨大**

*   **预训练阶段**：使用的数据集通常是亿级甚至万亿级的词元（Tokens）。庞大的数据量使得训练过程非常稳定，可以容忍相对较高的学习率，因为梯度的噪声可以被大量数据平滑掉。
*   **微调阶段**：使用的标注数据集通常非常小（从几百到几万个样本）。如果学习率过大，模型在小数据集上计算出的梯度可能会有很大的方差，导致权重更新的波动非常剧烈。这很容易“冲过”最优解，甚至完全破坏预训练学到的特征，导致**灾难性遗忘 (Catastrophic Forgetting)**。

**3. 模型状态：从“未开发”到“已优化”**

*   **预训练阶段**：模型从一个随机初始化的“山谷”底部开始，需要较大的步伐（学习率）才能有效地向山谷的更低处移动。
*   **微调阶段**：模型已经位于一个经过精心优化的“平原”或“盆地”中，这个位置对于解决通用语言任务已经非常好了。微调的目标是在这个优秀区域附近，找到一个能更好地解决特定任务的“小凹陷”。如果步伐（学习率）太大，模型可能会一步跨出这个优秀的平原，跑到很差的区域去，导致性能急剧下降。

**一个形象的比喻：**

*   **预训练**就像是**建造一栋大楼的毛坯房**。你需要大型机械（高学习率）和大量的建筑材料（海量数据）来快速搭建起稳固的结构（通用语言能力）。
*   **微调**就像是**对毛坯房进行精装修**以适应特定业主（下游任务）的需求。你需要的是小锤子、刷子等精细工具（低学习率）和少量的装修材料（小数据集），在不破坏主体结构的前提下，进行个性化的改造。如果你在精装修时还用挖掘机（高学习率），很可能会把墙都推倒（灾难性遗忘）。

**对其他超参数敏感的原因：**

同样的逻辑也适用于其他超参数，如 **batch size** 和 **epoch 数量**。

*   **Batch Size**：在小数据集上，过大的 batch size 可能会导致模型收敛到泛化能力差的尖锐最小值，而较小的 batch size 引入的噪声有时反而有助于找到泛化更好的平坦最小值。但太小的 batch size 会使梯度估计不准，训练不稳定。
*   **Epochs**：由于数据集很小，微调时训练的 epoch 数量通常很少（例如 2-4 个）。如果训练太多 epoch，模型会严重过拟合，完全记住训练集中的样本，而丧失泛化到未见数据的能力。

因此，在微调时，我们需要像一个“外科医生”一样，对超参数进行精细的调整和实验，以在保留通用知识和适应新任务之间找到最佳的平衡点。
## Q138：在命名实体识别任务中，当 BERT 将单词拆分成多个词元时，如何解决标签对齐问题？

**答案：**

在命名实体识别（Named Entity Recognition, NER）任务中，标签对齐问题是使用 BERT 等基于子词（Subword）分词模型时必须解决的核心问题。这个问题源于一个原始单词可能被拆分成多个词元（Tokens），而我们的标签是针对整个单词的。

例如，单词 `Washington` 可能被分为 `Washing` 和 `##ton` 两个词元。如果 `Washington` 是一个地点实体（`B-LOC`），那么 `Washing` 和 `##ton` 这两个词元应该对应什么标签呢？

解决这个问题主要有以下几种策略：

### 策略一：只为首个子词分配标签，忽略其余子词 (Head Subword Only)

这是最常用、最简单且效果最好的方法。

*   **做法**：
    1.  对于一个被拆分的单词，将其第一个子词的标签设置为原始单词的标签（例如，`B-LOC`）。
    2.  将其余的所有子词（以 `##` 开头的）的标签设置为一个特殊的忽略标签，例如 `-100`（在 PyTorch 中）或 `X`。这个特殊标签在计算损失函数时会被忽略，意味着这些子词的预测结果不参与模型的梯度更新。

*   **示例**：

| 原始词 | `George` | `Washington` | `went` | `to` | `New` | `York` |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **原始标签** | `B-PER` | `I-PER` | `O` | `O` | `B-LOC` | `I-LOC` |
| **BERT 词元** | `George` | `Washing` | `##ton` | `went` | `to` | `New` | `York` |
| **对齐后标签** | `B-PER` | `I-PER` | **-100** | `O` | `O` | `B-LOC` | `I-LOC` |

    *注意：在这个例子中，`Washington` 作为一个整体是 `I-PER`，所以其首个子词 `Washing` 继承了 `I-PER` 标签。* 

*   **优点**：
    *   **实现简单**：逻辑清晰，容易实现。
    *   **性能稳健**：在大量实践中被证明是效果最好的策略之一。模型只需要学会为每个单词的开头进行正确分类，减轻了学习负担。
    *   **避免不一致性**：避免了模型对同一个单词的多个部分做出不同预测的尴尬情况。

### 策略二：为所有子词分配相同标签 (All Subwords Same Label)

*   **做法**：将构成同一个单词的所有子词都赋予相同的标签。

*   **示例**：

| 原始词 | `Washington` |
| :--- | :--- |
| **原始标签** | `I-PER` |
| **BERT 词元** | `Washing` | `##ton` |
| **对齐后标签** | `I-PER` | `I-PER` |

*   **优点**：
    *   直观，保留了所有词元的信息。
*   **缺点**：
    *   **标签不平衡**：人为地增加了实体标签的数量，可能会加剧数据集中标签不平衡的问题。
    *   **任务混淆**：模型被要求对一个单词的中间部分（如 `##ton`）也做出独立的、完整的预测，这在逻辑上是不自然的，可能会给模型带来不必要的学习负担。
    *   **性能稍差**：在实践中，这种方法的效果通常不如策略一。

### 策略三：使用条件随机场 (CRF) 层

虽然这不是一个直接的标签对齐策略，但 CRF 层可以有效地约束标签序列的合法性，从而间接缓解对齐问题带来的影响。

*   **做法**：在 BERT 的输出层之上，增加一个 CRF 层。CRF 层可以学习到标签之间的转移概率（例如，`B-PER` 后面很可能跟着 `I-PER`，但不太可能跟着 `I-LOC`）。

*   **优点**：
    *   **保证标签序列的有效性**：可以避免产生如 `B-PER, I-LOC` 这样不合逻辑的标签序列。
    *   **提升整体性能**：通过考虑标签的依赖关系，通常能获得比单独使用 Softmax 分类头更好的 NER 性能。

*   **如何结合**：CRF 通常与**策略一**或**策略二**结合使用。BERT 输出每个词元的标签概率，然后将整个序列的概率输入到 CRF 层，由 CRF 层解码出最优的标签路径。

**总结与推荐**

| 策略 | 实现复杂度 | 性能 | 推荐指数 |
| :--- | :--- | :--- | :--- |
| **1. 首子词分配，其余忽略** | **低** | **高** | ★★★★★ (业界标准) |
| **2. 所有子词相同标签** | 低 | 中 | ★★☆☆☆ (不推荐) |
| **3. 结合 CRF 层** | 中 | 较高 | ★★★★☆ (追求更高性能时) |

对于绝大多数 NER 任务，**策略一（只为首个子词分配标签）** 是最推荐的起点。它简单、高效，并且是 Hugging Face 等主流库中的标准做法。如果希望进一步提升性能，可以在此基础上增加一个 **CRF 层**。
## Q139：如何用领域数据训练一个在嵌入式设备上使用的小模型，同时处理文本分类、命名实体识别和语义搜索三个任务？

**答案：**

这是一个典型的**多任务学习（Multi-Task Learning, MTL）** 与 **模型压缩（Model Compression）** 相结合的场景，目标是训练一个高效、轻量且多功能的领域模型。核心思路是让模型在共享表示层的基础上，学习多个相关任务，从而提升整体性能和效率。

以下是详细的实施方案：

### 1. 方案核心：硬参数共享的多任务学习

我们将采用**硬参数共享（Hard Parameter Sharing）** 的多任务学习架构。这是最常用且资源最节省的 MTL 方法。

*   **共享层（Shared Bottom）**：选择一个轻量级的预训练模型作为所有任务的共享编码器。它的作用是提取文本的通用语义特征。
*   **任务特定层（Task-Specific Heads）**：在共享编码器之上，为每个任务构建一个独立的、小型的输出层（“头”）。



### 2. 轻量级模型选择

考虑到嵌入式设备的算力限制，必须选择小规模的预训练模型作为起点。以下是一些优秀的选择：

| 模型 | 特点 | 适用场景 |
| :--- | :--- | :--- |
| **DistilBERT** | 通过知识蒸馏从 BERT 压缩而来，速度提升60%，保留97%性能。 | 通用首选，平衡了性能和速度。 |
| **MobileBERT** | 专为移动设备设计，通过深度和宽度调整，非常轻量。 | 对模型体积和延迟要求极高的场景。 |
| **TinyBERT** | 更深层次的知识蒸馏，模型极小，但性能损失可能稍大。 | 资源极其受限的设备。 |
| **CNN/LSTM+Word2Vec** | 非 Transformer 模型，如果领域词汇固定且任务简单，可以作为备选。 | 任务相对简单，或无法运行 Transformer 的环境。 |

**建议**：从 **DistilBERT** 开始，因为它在性能和效率之间取得了很好的平衡。

### 3. 构建任务特定的“头”

在共享的 DistilBERT 之上，为三个任务分别设计输出层：

1.  **文本分类头 (Text Classification Head)**：
    *   **输入**：获取 DistilBERT 输出的 `[CLS]` 词元的嵌入向量（Embedding）。这个向量代表了整个句子的聚合表示。
    *   **结构**：一个或两个线性层（Linear Layer）+ 一个 Softmax 激活函数，用于输出每个类别的概率。

2.  **命名实体识别头 (NER Head)**：
    *   **输入**：获取 DistilBERT 输出的**所有词元**的嵌入向量。
    *   **结构**：一个线性层，其输出维度等于 NER 标签的数量（如 `B-PER`, `I-PER`, `O` 等）。然后对每个词元独立进行分类。

3.  **语义搜索头 (Semantic Search Head)**：
    *   **目标**：让模型生成高质量的句子嵌入（Sentence Embedding），使得语义相似的句子在向量空间中距离更近。
    *   **结构**：通常是一个**池化层（Pooling Layer）**，将所有词元的输出向量聚合成一个定长的句子向量。
        *   **Mean Pooling**：计算所有输出词元向量的平均值。通常效果最好。
        *   **CLS Pooling**：直接使用 `[CLS]` 词元的输出向量。
    *   **训练目标**：此任务需要特定的损失函数，如**对比损失（Contrastive Loss）**。需要构造正负样本对（例如，来自同一类别的句子为正样本，不同类别的为负样本）来训练这个头。

### 4. 训练策略

1.  **数据准备**：
    *   将三个任务的领域数据整合在一起。
    *   为语义搜索任务构造**三元组（Triplets）**：`(anchor, positive, negative)`。例如，`anchor` 和 `positive` 是相似的句子，`negative` 是不相关的句子。

2.  **损失函数**：
    *   总损失是三个任务损失的加权和：
        $ L_{total} = w_1 \cdot L_{cls} + w_2 \cdot L_{ner} + w_3 \cdot L_{search} $
    *   `L_cls`：文本分类的交叉熵损失 (Cross-Entropy Loss)。
    *   `L_ner`：NER 的交叉熵损失（通常会忽略子词的非首个词元）。
    *   `L_search`：语义搜索的对比损失或三元组损失 (Triplet Loss)。
    *   权重 `w1, w2, w3` 是超参数，可以根据任务的重要性进行调整，初始可以都设为 1.0。

3.  **训练过程**：
    *   在每个训练批次中，可以混合来自不同任务的数据。
    *   当处理一个批次的数据时，计算其对应任务的损失，并进行反向传播。未涉及的任务的头的权重将不会被更新。
    *   这种方式可以平滑地同时优化所有任务。

### 5. 模型优化与部署

训练完成后，为了部署到嵌入式设备，必须进行优化：

1.  **知识蒸馏 (Knowledge Distillation)**：
    *   如果性能仍有提升空间，可以将训练好的多任务模型作为“教师模型”，去教一个更小的“学生模型”（例如，从 DistilBERT 蒸馏到 TinyBERT）。

2.  **量化 (Quantization)**：
    *   这是最关键的一步。将模型的权重从 32 位浮点数（FP32）转换为 8 位整数（INT8）。
    *   **效果**：模型体积减小约 **4倍**，推理速度提升 **2-3倍**，且对精度的影响通常很小。

3.  **剪枝 (Pruning)**：
    *   移除模型中冗余或不重要的权重，进一步减小模型体积。

4.  **格式转换**：
    *   将优化后的模型转换为适用于目标平台的格式，如 **TensorFlow Lite (.tflite)** 或 **ONNX**。

### 总结

通过“**轻量级模型 + 多任务学习 + 模型压缩**”三步走策略，可以高效地为嵌入式设备打造一个多功能的领域模型。这种方法不仅节省了分别训练和部署三个模型的巨大成本，还能通过任务间的知识共享提升模型的泛化能力。
## Q140：假设一个嵌入模型的训练语料主要由英文构成，其中文表现不佳，如何用较低的继续预训练成本，提升其中文能力？

**答案：**

这是一个典型的**模型跨语言能力迁移和增强**的问题。目标是在保留模型已有英文能力的基础上，以最低的成本注入强大的中文理解能力。直接从头开始训练一个多语言模型成本高昂，因此，采用**继续预训练（Continual Pre-training）** 是最高效的策略。

以下是详细的、分步骤的低成本方案：

### 1. 核心问题：词表不匹配 (Vocabulary Mismatch)

模型中文表现不佳的根本原因在于其**词表（Vocabulary）** 主要由英文字母和子词构成，对汉字的支持非常有限。一个中文字符可能会被拆分成多个无意义的 `[UNK]` (未知) 标记或多个字母的组合，导致模型无法学习到中文的语义信息。

**因此，第一步也是最关键的一步是扩充词表。**

### 2. 方案一：词表扩充 + 继续预训练 (Recommended)

这是最系统且效果最好的方法。

*   **步骤 1：扩充词表**
    1.  **准备中文语料**：收集一批高质量、多样化的中文文本数据。不需要海量数据，几 GB 到几十 GB 通常就足够。
    2.  **训练新的中文 Tokenizer**：使用这批中文语料训练一个专门的中文 Tokenizer（例如，基于 `WordPiece` 或 `BPE`）。
    3.  **合并词表**：将新训练的中文词表与模型原有的英文词表进行合并，创建一个新的、同时包含中英文的混合词表。
    4.  **扩展模型嵌入层**：由于词表变大了，需要相应地扩展模型中**词嵌入层（Token Embedding Layer）** 的权重矩阵。新加入的中文词向量可以随机初始化，也可以用某种平均值进行初始化。

*   **步骤 2：使用掩码语言模型（MLM）进行继续预训练**
    1.  **准备混合语料**：创建一个同时包含英文和中文文本的语料库。可以采用一定的比例，例如 50% 中文，50% 英文，以确保模型不会“忘记”英文。
    2.  **冻结大部分层**：为了降低计算成本并保留英文能力，可以**冻结（Freeze）** 模型底层的大部分 Transformer 层（例如，对于一个12层的模型，可以冻结前8-10层）。只训练顶部的几层和新扩展的词嵌入层。
    3.  **低学习率训练**：使用一个非常低的学习率（例如 `1e-5` 到 `5e-5`）进行训练。这有助于模型在新数据上平稳地学习，而不会灾难性地忘记旧知识。
    4.  **训练目标**：继续使用**掩码语言模型（Masked Language Modeling, MLM）** 作为训练目标。在混合语料上进行掩码和预测。

*   **优点**：
    *   从根本上解决了中文表示的问题。
    *   效果最好，能显著提升模型的中文理解能力。
    *   通过冻结和低学习率，有效降低了训练成本和“灾难性遗忘”的风险。

### 3. 方案二：仅使用参数高效微调 (PEFT) 技术 (Lower Cost, Potentially Lower Performance)

如果计算资源极其有限，可以尝试使用 LoRA 等参数高效微调技术，但这更像是在“修补”而不是“增强”。

*   **做法**：
    1.  **不修改词表**：保留原始的英文词表。这意味着模型将继续用次优的方式对中文进行分词。
    2.  **引入适配器（Adapter）或 LoRA**：在模型的 Transformer 层中插入少量可训练的参数（如 LoRA 矩阵）。
    3.  **在中文任务数据上微调**：冻结所有原始模型参数，只训练这些新增的、少量的适配器参数。训练数据可以是具体的下游任务数据（如中文分类、NER）。

*   **优点**：
    *   **成本极低**：需要更新的参数量非常少（可能只有原始模型的 0.1% - 1%）。
    *   **实现简单**：无需修改模型结构。
*   **缺点**：
    *   **性能天花板低**：由于没有解决核心的词表问题，模型对中文的理解能力提升有限。它更像是在学习一种“模式映射”，而不是真正的语言理解。
    *   **泛化能力差**：在一个任务上微调后，可能在其他中文任务上表现不佳。

### 总结与建议

| 方案 | 核心操作 | 成本 | 效果 | 推荐指数 |
| :--- | :--- | :--- | :--- | :--- |
| **1. 词表扩充 + 继续预训练** | 扩充词表，MLM继续训练 | 中等 | **高** | ★★★★★ |
| **2. PEFT (如 LoRA)** | 插入少量可训练参数 | **极低** | 中/低 | ★★★☆☆ |

**最终建议**：

为了真正且稳健地提升模型的中文能力，强烈推荐采用**方案一**。虽然它比方案二成本稍高，但它从根本上解决了问题，带来的性能提升是长远且显著的。通过**冻结大部分层**和**使用低学习率**，可以将“继续预训练”的成本控制在一个可接受的范围内。
## Q141：对于一个关键场景的分类任务，例如将“严重不良反应”误分类为“轻微不良反应”比反向错误更危险，如何选择评估指标，解决数据集类别不平衡的问题，并修改损失函数？

**答案：**

这是一个典型的**代价敏感学习（Cost-Sensitive Learning）** 和 **类别不平衡（Class Imbalance）** 问题。在这种场景下，我们的目标不再是最大化整体的准确率，而是**最小化由特定误分类引起的风险**。需要一个系统性的解决方案，涵盖评估、数据和模型三个层面。

### 1. 评估指标选择：从“准”到“不放过一个”

标准的准确率（Accuracy）在此场景下具有极大的误导性。如果“严重不良反应”的样本很少，模型即使将它们全部预测错误，也能获得很高的准确率。因此，必须采用更精细的指标。

*   **混淆矩阵 (Confusion Matrix)**：这是所有分析的基础。对于二分类问题（严重 vs. 轻微），它清晰地展示了四种结果：
    *   **真阳性 (TP)**：正确预测为“严重”。
    *   **假阳性 (FP)**：将“轻微”错误预测为“严重”。（“虚惊一场”）
    *   **真阴性 (TN)**：正确预测为“轻微”。
    *   **假阴性 (FN)**：将“严重”错误预测为“轻微”。（**这是最危险的错误！**）

*   **核心指标：召回率 (Recall / Sensitivity)**
    *   **公式**：`Recall = TP / (TP + FN)`
    *   **含义**：在所有**真正为“严重”** 的样本中，模型成功识别出了多少。
    *   **为什么最重要**：最大化召回率等同于最小化 **FN**。在这个场景下，我们宁愿“虚惊一场”（把轻微当成严重，FP高），也绝不能“放过一个”（把严重当成轻微，FN低）。因此，**“严重不良反应”类别的召回率是首要评估指标**。

*   **辅助指标**：
    *   **精确率 (Precision)**：`Precision = TP / (TP + FP)`。它衡量的是所有被模型预测为“严重”的样本中，有多少是真正的“严重”。高精确率意味着减少“虚惊一场”的情况。
    *   **F1-Score**：`F1 = 2 * (Precision * Recall) / (Precision + Recall)`。它是精确率和召回率的调和平均值，用于综合评估模型的性能。
    *   **AUC-PR (Precision-Recall Curve Area)**：比传统的 AUC-ROC 更适合评估不平衡数据集。

**结论**：以**“严重”类别的召回率**为北极星指标，同时监控 F1-Score 和 Precision，以确保模型在不过多误报的情况下，尽可能找出所有高风险样本。

### 2. 解决类别不平衡问题：让模型“看见”少数派

如果“严重”样本过少，模型可能无法充分学习其特征。可以从数据层面解决这个问题。

*   **过采样 (Oversampling)**：增加少数类样本的数量。
    *   **SMOTE (Synthetic Minority Over-sampling Technique)**：最流行的方法。它不是简单地复制少数类样本，而是通过在现有少数类样本之间进行插值来**合成新的、相似的样本**。这有助于模型学习到更泛化的决策边界。

*   **欠采样 (Undersampling)**：减少多数类样本的数量。
    *   **随机欠采样**：随机丢弃多数类样本。缺点是可能会丢失重要信息。
    *   **Tomek Links / Edited Nearest Neighbors (ENN)**：更智能的欠采样方法，通过移除那些模糊了类别边界的多数类样本来“清洁”数据集。

**建议**：优先尝试 **SMOTE**，因为它在扩充数据的同时避免了信息丢失。

### 3. 修改损失函数：让模型“知道”什么错误更严重

这是最直接的代价敏感学习方法，通过修改模型的“惩罚机制”来引导其行为。

*   **加权交叉熵损失 (Weighted Cross-Entropy Loss)**：
    *   **原理**：标准交叉熵损失对所有类别的权重都是1。在加权版本中，我们可以为不同类别的错误分配不同的权重。
    *   **做法**：为“严重不良反应”类别分配一个**远高于**“轻微不良反应”类别的权重。例如，如果轻微：严重 = 100:1，可以设置权重为 `weight=[1, 100]`。
    *   **效果**：当模型将一个“严重”样本误分类时，它会受到比普通错误大100倍的惩罚。这迫使模型投入更多精力去正确识别少数但关键的样本。

*   **Focal Loss**：
    *   **原理**：Focal Loss 是对交叉熵的改进，它有两个作用：
        1.  通过一个因子 `α` 来平衡类别权重（类似加权交叉熵）。
        2.  通过一个聚焦参数 `γ` (gamma) 来**降低简单样本的权重**，让模型专注于学习那些难分类的样本。
    *   **公式**：`FL(p_t) = -α_t * (1 - p_t)^γ * log(p_t)`
    *   **效果**：在类别不平衡的场景中，多数类样本通常是“简单样本”。Focal Loss 会自动降低这些简单样本对总损失的贡献，从而让模型集中火力去攻克那些少数的、难学的“严重”样本。

### 综合方案

| 层面 | 策略 | 具体方法 | 目标 |
| :--- | :--- | :--- | :--- |
| **评估** | 选择合适的指标 | **主看召回率 (Recall)**，辅看 F1-Score | 确保不漏掉任何一个高风险案例 |
| **数据** | 平衡类别分布 | **SMOTE** | 为模型提供充足的少数类学习信号 |
| **模型** | 引入代价敏感 | **加权交叉熵** 或 **Focal Loss** | 让模型知道犯不同错误的代价不同 |

**最终建议**：

1.  **首先**，将评估指标切换为**“严重”类别的召回率**。
2.  **其次**，在损失函数中引入**加权交叉熵**，直接告诉模型“严重”类别的重要性。
3.  **如果效果仍不理想**，在训练数据上应用 **SMOTE** 来创造更多样的少数派样本。
4.  **作为进阶选项**，可以尝试使用 **Focal Loss** 来让模型自动聚焦于困难样本。
